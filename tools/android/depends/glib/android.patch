--- glib/gutils.c	2010-11-12 08:52:52.000000000 -0500
+++ glib/gutils.c	2012-10-10 18:20:31.437330453 -0400
@@ -1692,16 +1692,19 @@
     while (!pw);
 #  endif /* HAVE_POSIX_GETPWUID_R || HAVE_NONPOSIX_GETPWUID_R */
     
+#if !defined(ANDROID)
     if (!pw)
       {
 	setpwent ();
 	pw = getpwuid (getuid ());
 	endpwent ();
       }
+#endif
     if (pw)
       {
 	g_user_name = g_strdup (pw->pw_name);
 
+#if !defined(ANDROID)
 	if (pw->pw_gecos && *pw->pw_gecos != '\0') 
 	  {
 	    gchar **gecos_fields;
@@ -1715,7 +1718,7 @@
 	    g_strfreev (gecos_fields);
 	    g_strfreev (name_parts);
 	  }
-
+#endif
 	if (!g_home_dir)
 	  g_home_dir = g_strdup (pw->pw_dir);
       }

--- gio/gresolver.c	2012-10-10 18:19:29.767330494 -0400
+++ gio/gresolver.c	2012-10-10 18:59:44.307328972 -0400
@@ -73,6 +73,60 @@
 #endif
 };
 
+#ifdef ANDROID
+/*%
+ * Inline versions of get/put short/long.  Pointer is advanced.
+ */
+#define NS_INT32SZ    4    /*%< #/bytes of data in a u_int32_t */
+#define NS_INT16SZ    2    /*%< #/bytes of data in a u_int16_t */
+#define NS_GET16(s, cp) do { \
+    register const u_char *t_cp = (const u_char *)(cp); \
+    (s) = ((u_int16_t)t_cp[0] << 8) \
+        | ((u_int16_t)t_cp[1]) \
+        ; \
+    (cp) += NS_INT16SZ; \
+} while (0)
+#define NS_GET32(l, cp) do { \
+    register const u_char *t_cp = (const u_char *)(cp); \
+    (l) = ((u_int32_t)t_cp[0] << 24) \
+        | ((u_int32_t)t_cp[1] << 16) \
+        | ((u_int32_t)t_cp[2] << 8) \
+        | ((u_int32_t)t_cp[3]) \
+        ; \
+    (cp) += NS_INT32SZ; \
+} while (0)
+
+
+#define    GETSHORT        NS_GET16
+#define    GETLONG            NS_GET32
+
+#define ns_c_in     1    /*%< Internet. */
+#define ns_t_srv     33    /*%< Internet. */
+#define C_IN        ns_c_in
+#define    T_SRV        ns_t_srv
+
+typedef struct {
+    unsigned    id :16;        /*%< query identification number */
+            /* fields in third byte */
+    unsigned    rd :1;        /*%< recursion desired */
+    unsigned    tc :1;        /*%< truncated message */
+    unsigned    aa :1;        /*%< authoritive answer */
+    unsigned    opcode :4;    /*%< purpose of message */
+    unsigned    qr :1;        /*%< response flag */
+            /* fields in fourth byte */
+    unsigned    rcode :4;    /*%< response code */
+    unsigned    cd: 1;        /*%< checking disabled by resolver */
+    unsigned    ad: 1;        /*%< authentic data from named */
+    unsigned    unused :1;    /*%< unused bits (MBZ as of 4.9.3a3) */
+    unsigned    ra :1;        /*%< recursion available */
+            /* remaining bytes */
+    unsigned    qdcount :16;    /*%< number of question entries */
+    unsigned    ancount :16;    /*%< number of answer entries */
+    unsigned    nscount :16;    /*%< number of authority entries */
+    unsigned    arcount :16;    /*%< number of resource entries */
+} HEADER;
+#endif
+
 /**
  * GResolver:
  *
--- gio/libasyncns/asyncns.c	2012-10-10 18:19:29.777330494 -0400
+++ gio/libasyncns/asyncns.c	2012-10-10 18:57:08.007329070 -0400
@@ -201,6 +201,29 @@
     res_response_t res_response;
 } packet_t;
 
+#ifdef ANDROID
+typedef struct {
+    unsigned    id :16;        /*%< query identification number */
+            /* fields in third byte */
+    unsigned    rd :1;        /*%< recursion desired */
+    unsigned    tc :1;        /*%< truncated message */
+    unsigned    aa :1;        /*%< authoritive answer */
+    unsigned    opcode :4;    /*%< purpose of message */
+    unsigned    qr :1;        /*%< response flag */
+            /* fields in fourth byte */
+    unsigned    rcode :4;    /*%< response code */
+    unsigned    cd: 1;        /*%< checking disabled by resolver */
+    unsigned    ad: 1;        /*%< authentic data from named */
+    unsigned    unused :1;    /*%< unused bits (MBZ as of 4.9.3a3) */
+    unsigned    ra :1;        /*%< recursion available */
+            /* remaining bytes */
+    unsigned    qdcount :16;    /*%< number of question entries */
+    unsigned    ancount :16;    /*%< number of answer entries */
+    unsigned    nscount :16;    /*%< number of authority entries */
+    unsigned    arcount :16;    /*%< number of resource entries */
+} HEADER;
+#endif
+
 #ifndef HAVE_STRNDUP
 
 static char *strndup(const char *s, size_t l) {
@@ -979,7 +1002,6 @@
 
     return (const uint8_t*) p + l;
 
-
 fail:
     if (ai)
         _g_asyncns_freeaddrinfo(ai);
--- gio/gthreadedresolver.c	2012-10-10 18:19:29.777330494 -0400
+++ gio/gthreadedresolver.c	2012-10-10 19:01:02.787328922 -0400
@@ -35,6 +35,61 @@
 #include "gsocketaddress.h"
 
 
+#ifdef ANDROID
+/*%
+ * Inline versions of get/put short/long.  Pointer is advanced.
+ */
+#define NS_INT32SZ    4    /*%< #/bytes of data in a u_int32_t */
+#define NS_INT16SZ    2    /*%< #/bytes of data in a u_int16_t */
+#define NS_GET16(s, cp) do { \
+    register const u_char *t_cp = (const u_char *)(cp); \
+    (s) = ((u_int16_t)t_cp[0] << 8) \
+        | ((u_int16_t)t_cp[1]) \
+        ; \
+    (cp) += NS_INT16SZ; \
+} while (0)
+#define NS_GET32(l, cp) do { \
+    register const u_char *t_cp = (const u_char *)(cp); \
+    (l) = ((u_int32_t)t_cp[0] << 24) \
+        | ((u_int32_t)t_cp[1] << 16) \
+        | ((u_int32_t)t_cp[2] << 8) \
+        | ((u_int32_t)t_cp[3]) \
+        ; \
+    (cp) += NS_INT32SZ; \
+} while (0)
+
+
+#define    GETSHORT        NS_GET16
+#define    GETLONG            NS_GET32
+
+#define ns_c_in     1    /*%< Internet. */
+#define ns_t_srv     33    /*%< Internet. */
+#define C_IN        ns_c_in
+#define    T_SRV        ns_t_srv
+
+    typedef struct {
+        unsigned    id :16;        /*%< query identification number */
+        /* fields in third byte */
+        unsigned    rd :1;        /*%< recursion desired */
+        unsigned    tc :1;        /*%< truncated message */
+        unsigned    aa :1;        /*%< authoritive answer */
+        unsigned    opcode :4;    /*%< purpose of message */
+        unsigned    qr :1;        /*%< response flag */
+        /* fields in fourth byte */
+        unsigned    rcode :4;    /*%< response code */
+        unsigned    cd: 1;        /*%< checking disabled by resolver */
+        unsigned    ad: 1;        /*%< authentic data from named */
+        unsigned    unused :1;    /*%< unused bits (MBZ as of 4.9.3a3) */
+        unsigned    ra :1;        /*%< recursion available */
+        /* remaining bytes */
+        unsigned    qdcount :16;    /*%< number of question entries */
+        unsigned    ancount :16;    /*%< number of answer entries */
+        unsigned    nscount :16;    /*%< number of authority entries */
+        unsigned    arcount :16;    /*%< number of resource entries */
+    } HEADER;
+#endif
+
+
 G_DEFINE_TYPE (GThreadedResolver, g_threaded_resolver, G_TYPE_RESOLVER)
 
 static void threaded_resolver_thread (gpointer thread_data, gpointer pool_data);
--- gio/gunixresolver.c	2012-10-10 18:19:29.777330494 -0400
+++ gio/gunixresolver.c	2012-10-10 19:01:49.517328893 -0400
@@ -34,6 +34,59 @@
 #include "gsimpleasyncresult.h"
 #include "gsocketaddress.h"
 
+#ifdef ANDROID
+/*%
+ * Inline versions of get/put short/long.  Pointer is advanced.
+ */
+#define NS_INT32SZ    4    /*%< #/bytes of data in a u_int32_t */
+#define NS_INT16SZ    2    /*%< #/bytes of data in a u_int16_t */
+#define NS_GET16(s, cp) do { \
+    register const u_char *t_cp = (const u_char *)(cp); \
+    (s) = ((u_int16_t)t_cp[0] << 8) \
+        | ((u_int16_t)t_cp[1]) \
+        ; \
+    (cp) += NS_INT16SZ; \
+} while (0)
+#define NS_GET32(l, cp) do { \
+    register const u_char *t_cp = (const u_char *)(cp); \
+    (l) = ((u_int32_t)t_cp[0] << 24) \
+        | ((u_int32_t)t_cp[1] << 16) \
+        | ((u_int32_t)t_cp[2] << 8) \
+        | ((u_int32_t)t_cp[3]) \
+        ; \
+    (cp) += NS_INT32SZ; \
+} while (0)
+
+
+#define    GETSHORT        NS_GET16
+#define    GETLONG            NS_GET32
+
+#define ns_c_in     1    /*%< Internet. */
+#define ns_t_srv     33    /*%< Internet. */
+#define C_IN        ns_c_in
+#define    T_SRV        ns_t_srv
+
+    typedef struct {
+        unsigned    id :16;        /*%< query identification number */
+        /* fields in third byte */
+        unsigned    rd :1;        /*%< recursion desired */
+        unsigned    tc :1;        /*%< truncated message */
+        unsigned    aa :1;        /*%< authoritive answer */
+        unsigned    opcode :4;    /*%< purpose of message */
+        unsigned    qr :1;        /*%< response flag */
+        /* fields in fourth byte */
+        unsigned    rcode :4;    /*%< response code */
+        unsigned    cd: 1;        /*%< checking disabled by resolver */
+        unsigned    ad: 1;        /*%< authentic data from named */
+        unsigned    unused :1;    /*%< unused bits (MBZ as of 4.9.3a3) */
+        unsigned    ra :1;        /*%< recursion available */
+        /* remaining bytes */
+        unsigned    qdcount :16;    /*%< number of question entries */
+        unsigned    ancount :16;    /*%< number of answer entries */
+        unsigned    nscount :16;    /*%< number of authority entries */
+        unsigned    arcount :16;    /*%< number of resource entries */
+    } HEADER;
+#endif
 
 G_DEFINE_TYPE (GUnixResolver, g_unix_resolver, G_TYPE_THREADED_RESOLVER)
 
--- gio/glocalfileinfo.c	2012-10-10 18:19:29.777330494 -0400
+++ gio/glocalfileinfo.c	2012-10-10 19:18:43.707328253 -0400
@@ -1096,8 +1096,11 @@
       if (pwbufp->pw_name != NULL && pwbufp->pw_name[0] != 0)
 	data->user_name = convert_pwd_string_to_utf8 (pwbufp->pw_name);
 
+#ifdef ANDROID
+      gecos = NULL;
+#else
       gecos = pwbufp->pw_gecos;
+#endif
-
       if (gecos)
 	{
 	  comma = strchr (gecos, ',');
